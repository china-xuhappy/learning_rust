// 所有权（https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html）
// 通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译

// 堆和栈
// 栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）

// 在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间
// 在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）


// 所有权规则
    // Rust 中的每一个值都有一个 所有者（owner）。
    // 值在任一时刻有且只有一个所有者。
    // 当所有者（变量）离开作用域，这个值将被丢弃。



fn main() {
    // 变量的作用域
    let s = "hello";
    // 变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 作用域 结束时都是有效的

    // {   // s 在这里无效，它尚未声明
    //     let s = "hello";   // 从此处起，s 是有效的
    //     // 使用 s
    // }   // 此作用域已结束，s 不再有效
    
    
    // 前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈

    
    // String
    let mut s = String::from("111");
    s.push_str(", world!"); // push_str() 在字符串后追加字面值
    println!("{}", s); // 将打印 `hello, world!`


    // 内存与分配
        // 就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中
        // String 类型，要在堆上分配一块在编译时未知大小的内存来存放内容

        // 必须在运行时向内存分配器（memory allocator）请求内存。 调用 String::from 时，它的实现 (implementation) 请求其所需的内存
        // 需要一个当我们处理完 String 时将内存返回给分配器的方法。 内存在拥有它的变量离开作用域后就被自动释放
        {
            let s = String::from("hello"); // 从此处起，s 是有效的
    
            // 使用 s
        }                                          // 此作用域已结束， 自动调用 drop
            // s 不再有效

    // 变量与数据交互的方式（一）：移动
        // 将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y
        // 整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中 
        let x = 5;
        let y = x;


        let s1 = String::from("hello");
        let s2 = s1;


}
