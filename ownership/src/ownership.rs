// 所有权（https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html）
// 通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译

// 堆和栈
// 栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）

// 在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间
// 在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）


// 所有权规则
    // Rust 中的每一个值都有一个 所有者（owner）。
    // 值在任一时刻有且只有一个所有者。
    // 当所有者（变量）离开作用域，这个值将被丢弃。



    fn main() {
        // 变量的作用域
        let s = "hello";
        // 变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 作用域 结束时都是有效的
    
        // {   // s 在这里无效，它尚未声明
        //     let s = "hello";   // 从此处起，s 是有效的
        //     // 使用 s
        // }   // 此作用域已结束，s 不再有效
        
        
        // 前面介绍的类型都是已知大小的，可以存储在栈中，并且当离开作用域时被移出栈
    
        
        // String
        let mut s = String::from("111");
        s.push_str(", world!"); // push_str() 在字符串后追加字面值
        println!("{}", s); // 将打印 `hello, world!`
    
    
        // 内存与分配
            // 就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中
            // String 类型，要在堆上分配一块在编译时未知大小的内存来存放内容
    
            // 必须在运行时向内存分配器（memory allocator）请求内存。 调用 String::from 时，它的实现 (implementation) 请求其所需的内存
            // 需要一个当我们处理完 String 时将内存返回给分配器的方法。 内存在拥有它的变量离开作用域后就被自动释放
            {
                let s = String::from("hello"); // 从此处起，s 是有效的
        
                // 使用 s
            }                                          // 此作用域已结束， 自动调用 drop
                // s 不再有效
    
        // 变量与数据交互的方式（一）：移动
            // 将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y
            // 整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中 
            let x = 5;
            let y = x;
    
    
            let s1 = String::from("hello");
            let s2 = s1; // 第二行可能会生成一个 s1 的拷贝并绑定到 s2 上。不过，事实上并不完全是这样
            
            // 一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。
            // ptr  指针   -> 指针指向 堆      堆存放  0 h  1 e  2 l 3 l 4 o
            // len 长度        长度表示 String 的内容当前使用了多少字节的内存
            // capacity 容量     容量是 String 从分配器总共获取了多少字节的内存
    
    
            // 当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据
            // 目前是 s1 和 s2 指针都指向同一个 堆里面的数据
            // 变量 s2 的内存表现，它有一份 s1 指针、长度和容量的拷贝
            // 如果 Rust 也拷贝了堆上的数据，那么操作 s2 = s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响。
    
            // 为了确保内存安全（二次释放），在 let s2 = s1; 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西
            // println!("{}, world!", s1);  borrow of moved value: `s1`
    
            // 那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，
            // 这个操作被称为 移动（move），而不是叫做浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中
    
            // Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制都可以被认为是对运行时性能影响较小的
    
    
    
        // 变量与数据交互的方式（二）：克隆
            // 可以使用一个叫做 clone 的通用函数
            let s1 = String::from("hello");
            let s2 = s1.clone(); // 堆上的数据 确实 被复制了。
            println!("s1 = {}, s2 = {}", s1, s2);
    
        
        // 只在栈上的数据：拷贝
            let x = 5;
            let y = x; // 没有调用 clone，不过 x 依然有效且没有被移动到 y 中。
            println!("x = {}, y = {}", x, y);
    
            // 整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效
    
            // 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
            // Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait
    
            // 任何一组简单标量值的组合都可以实现 Copy，任何 不需要分配内存或某种形式资源的类型都可以实现 Copy
                // 所有整数类型，比如 u32。
                // 布尔类型，bool，它的值是 true 和 false。
                // 所有浮点数类型，比如 f64。
                // 字符类型，char。
                // 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
        
        // 所有权与函数
            // 将值传递给函数与给变量赋值的原理相似  向函数传递值可能会移动或者复制，就像赋值语句一样
            let s = String::from("hello");  // s 进入作用域
            takes_ownership(s);             // s 的值移动到函数里 ...
                                            // ... 所以到这里不再有效
            let x = 5;                      // x 进入作用域
        
            makes_copy(x);                  // x 应该移动函数里，
                                            // 但 i32 是 Copy 的，
                                            // 所以在后面可继续使用 x
    }// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
      // 没有特殊之处
    
    fn takes_ownership(some_string: String) { // some_string 进入作用域
        println!("{}", some_string);
    } // 这里，some_string 移出作用域并调用 `drop` 方法。
      // 占用的内存被释放
    
    fn makes_copy(some_integer: i32) { // some_integer 进入作用域
        println!("{}", some_integer);
    } // 这里，some_integer 移出作用域。没有特殊之处
    
    
    
    // 返回值与作用域   返回值也可以转移所有权
        // 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。
    
    // fn main() {
    //     let s1 = gives_ownership();         // gives_ownership 将返回值
    //                                         // 转移给 s1
    
    //     let s2 = String::from("hello");     // s2 进入作用域
    
    //     let s3 = takes_and_gives_back(s2);  // s2 被移动到
    //                                         // takes_and_gives_back 中，
    //                                         // 它也将返回值移给 s3
    // } // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
    //   // 所以什么也不会发生。s1 离开作用域并被丢弃
    
    // fn gives_ownership() -> String {             // gives_ownership 会将
    //                                              // 返回值移动给
    //                                              // 调用它的函数
    
    //     let some_string = String::from("yours"); // some_string 进入作用域。
    
    //     some_string                              // 返回 some_string 
    //                                              // 并移出给调用的函数
    //                                              // 
    // }
    
    // // takes_and_gives_back 将传入字符串并返回该值
    // fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
    //                                                       // 
    
    //     a_string  // 返回 a_string 并移出给调用的函数
    // }
    
    
    // 但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，
    // 每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。
    
    // 引用（references）。